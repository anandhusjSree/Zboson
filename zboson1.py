# -*- coding: utf-8 -*-
"""Zboson1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f0n85z9vJ6ZgEIeILlhfi1Y5mv4BY_l3
"""

!pip install uproot awkward
!pip install vector
!pip install matplotlib
!pip install numpy
!pip install scipy

import uproot
import vector
import awkward as ak
import numpy as np
import matplotlib.pyplot as plt

from google.colab import files
uploaded = files.upload()

file=uproot.open("Zboson.root")
print(file.keys())

tree = file["Events;1"]
print(tree.keys())

events = file["Events;1"]

branches = tree.keys()
z_boson_branches = [b for b in branches if "Electron" in b]
print(z_boson_branches)

events = file["Events;1"]

branches = tree.keys()
electrons_branches = [b for b in branches if "Muon" in b]
print(electrons_branches)

events = file["Events;1"]

branches = tree.keys()

# Only show muon-related branches
muon_branches = [b for b in branches if "Muon" in b]
print(muon_branches)

mu_pt  = events["Muon_pt"].array()
mu_eta = events["Muon_eta"].array()
mu_phi = events["Muon_phi"].array()
mu_m   = events["Muon_mass"].array()

# Create Lorentz vectors for all muons
muons = vector.awkward.zip({
    "pt": mu_pt,
    "eta": mu_eta,
    "phi": mu_phi,
    "mass": mu_m
})

# Create a mask for events with exactly two muons
mask = ak.num(mu_pt) == 2
# Apply the mask to all muon arrays
di_muon_pt = mu_pt[mask]
di_muon_eta = mu_eta[mask]
di_muon_phi = mu_phi[mask]
muon_k= muons[mask]

# Select the first and second muons in each event
muon1_pt = di_muon_pt[:, 0]
muon2_pt = di_muon_pt[:, 1]

muon1_eta = di_muon_eta[:, 0]
muon2_eta = di_muon_eta[:, 1]

muon1_phi = di_muon_phi[:, 0]
muon2_phi = di_muon_phi[:, 1]

# Calculate invariant mass using the formula
dimuon_mass = np.sqrt(
    2 * muon1_pt * muon2_pt * (
        np.cosh(muon1_eta - muon2_eta) - np.cos(muon1_phi - muon2_phi)
    )
)

# 6. Optional: plot the invariant mass distribution
plt.hist(ak.to_numpy(dimuon_mass), bins=60, range=(50,130))
plt.xlabel("Dimuon invariant mass [GeV]")
plt.ylabel("Number of events")
plt.title("Z → μμ")
plt.show()

bin_width = 1.0  # GeV
mass_min = 60    # GeV
mass_max = 120   # GeV
bins = int((mass_max - mass_min) / bin_width)

# Plot histogram
plt.hist(dimuon_mass, bins=bins, range=(mass_min, mass_max), histtype='stepfilled', color='skyblue')
plt.xlabel("Dimuon invariant mass [GeV]")
plt.ylabel("Number of events")
plt.title(r"$Z \rightarrow \mu\mu$")
plt.show()

print("Total events:", len(muons))
print("Events with = muons:", len(muon_k))

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# define gaussian
def gaussian(x, A, mu, sigma):
    return A * np.exp(-(x - mu)**2 / (2*sigma**2))

# data (convert awkward → numpy)
masses = ak.to_numpy(dimuon_mass)

# histogram
counts, bins = np.histogram(masses, bins=80, range=(60,120))
bin_centers = 0.5 * (bins[1:] + bins[:-1])

# fit
popt, pcov = curve_fit(gaussian, bin_centers, counts, p0=[100, 91, 2])

# plot
plt.hist(masses, bins=80, range=(60,120), alpha=0.6, label="Data")
plt.plot(bin_centers, gaussian(bin_centers, *popt), 'r-', label="Fit")
plt.xlabel("Invariant mass [GeV]")
plt.ylabel("Events")
plt.legend()
plt.show()

print("Fit results:")
print(f"Mean (Z mass)  = {popt[1]:.2f} GeV")
print(f"Sigma (width)  = {popt[2]:.2f} GeV")

def model(x, A, M, Gamma, B, C):
    return breit_wigner(x, A, M, Gamma) + B + C*x



def breit_wigner(x, A, M, Gamma):
    return A * (Gamma**2) / ((x-M)**2 + (Gamma**2)/4)

popt, pcov = curve_fit(breit_wigner, bin_centers, counts, p0=[1000, 91, 2.5])

plt.hist(masses, bins=80, range=(60,120), alpha=0.6, label="Data")
plt.plot(bin_centers, breit_wigner(bin_centers, *popt), 'g-', label="Breit-Wigner Fit")
plt.xlabel("Invariant mass [GeV]")
plt.ylabel("Events")
plt.legend()
plt.show()

print("Breit-Wigner fit results:")
print(f"Mass   = {popt[1]:.2f} GeV")
print(f"Width  = {popt[2]:.2f} GeV")

def model(x, A, M, Gamma, B, C):
    return breit_wigner(x, A, M, Gamma) + B + C*x

import numpy as np
m = ak.to_numpy(dimuon_mass)
print("count events:", len(m))
print("min, max:", np.nanmin(m), np.nanmax(m))
print("nan count:", np.isnan(m).sum())

counts, bins = np.histogram(m, bins=50, range=(60,120))
print("sum counts:", counts.sum())  # should equal number of masses (or number of entries after masking)

import matplotlib.pyplot as plt
import numpy as np

# Convert awkward array to numpy
mass = ak.to_numpy(dimuon_mass)

# Make histogram
plt.hist(mass, bins=80, range=(60,120), histtype='step', color='blue')
plt.xlabel("Dimuon invariant mass [GeV]")
plt.ylabel("Events")
plt.title("Z Boson Candidate Events")
plt.grid(True)
plt.show()

from scipy.optimize import curve_fit

# Define Gaussian function
def gaussian(x, A, mu, sigma):
    return A * np.exp(-(x - mu)**2 / (2 * sigma**2))

# Create histogram data
counts, bin_edges = np.histogram(mass, bins=80, range=(60,120))
bin_centers = 0.5 * (bin_edges[1:] + bin_edges[:-1])

# Initial guesses: amplitude, mean, sigma
p0 = [max(counts), 91, 2]

# Fit
params, cov = curve_fit(gaussian, bin_centers, counts, p0=p0)
A, mu, sigma = params

print(f"Fitted Z boson mass = {mu:.2f} GeV")
print(f"Width (sigma) = {sigma:.2f} GeV")

# Plot fit
plt.hist(mass, bins=80, range=(60,120), histtype='step', color='blue', label="Data")
plt.plot(bin_centers, gaussian(bin_centers, *params), 'r-', label='Gaussian Fit')
plt.xlabel("Dimuon invariant mass [GeV]")
plt.ylabel("Events")
plt.legend()
plt.title(f"Z Boson Fit: mean = {mu:.2f} GeV, sigma = {sigma:.2f} GeV")
plt.show()

print(ak.num(muons))







